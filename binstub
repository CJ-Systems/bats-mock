#!/usr/bin/env bash
set -e

# If stdin comes from a pipe, save its content for later
if ! [ -t 0 ]; then
	input="$(cat)"
fi

status=0
program="${0##*/}"
PROGRAM="$(echo "$program" | tr a-z- A-Z_)"

_STUB_PLAN="${PROGRAM}_STUB_PLAN"
_STUB_RUN="${PROGRAM}_STUB_RUN"
_STUB_INDEX="${PROGRAM}_STUB_INDEX"
_STUB_RESULT="${PROGRAM}_STUB_RESULT"
_STUB_END="${PROGRAM}_STUB_END"
_STUB_DEBUG="${PROGRAM}_STUB_DEBUG"

debug() {
  if [ -n "${!_STUB_DEBUG}" ] ; then
    pattern=$1
    shift
    printf "bats-mock(%s): $pattern\\n" "$program" "${@}" >&${!_STUB_DEBUG}
  fi
}

# from https://github.com/lox/bash-shellwords
tokenize_shell_string() {
  local input="$1"
  local token=''
  local escape=''
  local quote=''
  local quote_idx=''

  tokenize_result=()

  # Process the input character by character
  for (( i=0 ; i<=${#input} ; i++ )) ; do
    c=${input:i:1}
    # debug '%-2q [#%d] [escape=%q] [quote=%q] [current=%q]' "$c" "$i" "$escape" "$quote" "$token"
    # Handle an escaped character
    if [[ -n "$escape" ]] ; then
      token+="$c"
      escape=''
    # Handles an unescaped backslash, denoting that the next char is escaped
    # Note that single quotes don't support escaping internally
    elif [[ "$c" == \\ ]] && [[ "$quote" != "'" ]] ; then
      escape="$c"
    # Handle open quotes
    elif [[ "$c" =~ [\"|\'] ]] && [[ -z "$quote" ]]; then
      quote="$c"
      quote_idx=$i
    # Handle matching closed quotes
    elif [[ -n "$quote" ]] && [[ "$c" == "$quote" ]]; then
      # debug "closing quote [%q]" "$token"
      # Handle empty quotes
      if [[ -z "$token" ]] ; then
        tokenize_result+=("$token")
      fi
      quote=''
      quote_idx=''
    # Handle whitespace delimiters when outside of quotes
    elif [[ -n "$token" ]] && [[ -z "$quote" ]] && [[ "$c" =~ [[:space:]] ]] ; then
      # debug "adding token [%q]" "$token"
      tokenize_result+=("$token")
      token=''
    # End of input
    elif [[ $i == "${#input}" ]] && [[ -n "$token" ]] ; then
      if [[ -n "$quote" ]] ; then
        echo "Unexpected end of string, quote not closed from index $quote_idx" >&2
        return 1
      fi
      # debug "adding token [%q]" "$token"
      tokenize_result+=("$token")
      token=''
    # Any other token
    else
      # Detect unescaped dollar signs in double quotes
      if [[ "$c" == '$' ]] && [[ "$quote" == '"' ]] ; then
        return 100
      # Detect shell characters when not quoted
      elif [[ -z "$quote" ]] && [[ "$c" =~ [][\!\#\$\&\(\)\*\;\<\>\?\\\^\`\{\}] ]] ; then
        return 100
      fi
      # Only capture spaces inside a token
      if [[ "$c" =~ [[:space:]] ]] && [[ -z "$token" ]]; then
        # debug "skipping space"
        continue
      else
        token+="$c"
      fi
    fi
  done
}

[ -e "${!_STUB_PLAN}" ] || exit 1
[ -n "${!_STUB_RUN}" ] || eval "${_STUB_RUN}"="${BATS_MOCK_TMPDIR}/${program}-stub-run"

# Initialize or load the stub run information.
eval "${_STUB_INDEX}"=1
eval "${_STUB_RESULT}"=0
[ ! -e "${!_STUB_RUN}" ] || source "${!_STUB_RUN}"

# if [ -z "${!_STUB_END}" ] && [ -n "${!_STUB_DEBUG}" ]; then
#   debug "%s" "$*" >&${!_STUB_DEBUG}
# fi

# Loop over each line in the plan.
index=0
while IFS= read -r line; do
  index=$((index + 1))

  # if [ -n "${!_STUB_DEBUG}" ]; then
  #   echo "bats-mock: [idx $index, want ${!_STUB_INDEX}] $line" >&${!_STUB_DEBUG}
  # fi

  if [ -z "${!_STUB_END}" ] && [ $index -eq "${!_STUB_INDEX}" ]; then
    # We found the plan line we're interested in.
    # Start off by assuming success.
    result=0

    # Split the line into an array of arguments to
    # match and a command to run to produce output.
    command=" $line"
    if [ "$command" != "${command/ : }" ]; then
      patterns="${command%% : *}"
      command="${command#* : }"
    fi

    # debug "patterns = $patterns"
    # debug "command = $command"

    arguments=("$@")
    tokenize_shell_string "$patterns" || exit 1

    # debug "tokenize_result [${#tokenize_result[@]}] = $(printf "'%q' " "${tokenize_result[@]}")"
    # debug "arguments [${#arguments[@]}] = $(printf "'%q' " "${arguments[@]}")"

    matched=0

    # Match the expected argument patterns to actual arguments.
    for (( i=0; i<${#tokenize_result[@]}; i++ )); do
      pattern="${tokenize_result[$i]}"
      argument="${arguments[$i]}"

      if [[ "$pattern" != "$argument" ]] && [[ "$pattern" != "*" ]] ; then
        debug "$(printf "match failed at idx %d, expected '%q', got '%q'" $i "$pattern" "$argument")"
        result=1
        break
      fi

      matched=$((matched + 1))
    done

    # If the number of arguments didn't match complain about it
    if [[ $matched -ne ${#tokenize_result[@]} ]] ; then
      debug "$(printf "matched %d arguments, expected %d" "$matched" "${#tokenize_result[@]}")"
      eval "${_STUB_RESULT}"=2
      continue
    fi

    # If the arguments matched, evaluate the command
    # in a subshell. Otherwise, log the failure.
    if [ $result -eq 0 ] ; then
      debug "running $command"
      debug "command input is $input"
      set +e
      ( eval "$command"  <<< "$input" )
      status="$?"
      debug "command result was $status"
      set -e
    else
      eval "${_STUB_RESULT}"=1
    fi
  fi
done < "${!_STUB_PLAN}"


if [ -n "${!_STUB_END}" ]; then
  echo "${_STUB_DEBUG}"
  debug "unstubbing"

  if [ ! -f "${!_STUB_RUN}" ] && [ -n "${!_STUB_DEBUG}" ] ; then
    echo "The stub for ${program} wasn't run"
    exit 1
  fi

  # Clean up the run file.
  rm -f "${!_STUB_RUN}"

  # If the number of lines in the plan is larger than
  # the requested index, we failed.
  if [ $index -ge "${!_STUB_INDEX}" ]; then
    eval "${_STUB_RESULT}"=1
  fi

  # Return the result.
  exit "${!_STUB_RESULT}"
else
  # If the requested index is larger than the number
  # of lines in the plan file, we failed.
  if [ "${!_STUB_INDEX}" -gt $index ]; then
    debug "no plan row found"
    eval "${_STUB_RESULT}"=1
  fi

  # Write out the run information.
  { echo "${_STUB_INDEX}=$((${!_STUB_INDEX} + 1))"
    echo "${_STUB_RESULT}=${!_STUB_RESULT}"
  } > "${!_STUB_RUN}"

  debug "result $status"
  exit "$status"
fi

